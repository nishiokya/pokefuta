#!/usr/bin/env python3
"""
ポケふたNDJSONデータからPostgreSQL INSERTステートメントを生成するスクリプト

使い方:
    # 全件出力
    python tools/generate_manhole_sql.py

    # ID 100以下のみ出力
    python tools/generate_manhole_sql.py --max-id 100

    # ID 50から100まで出力
    python tools/generate_manhole_sql.py --min-id 50 --max-id 100

    # ID 200以上のみ出力
    python tools/generate_manhole_sql.py --min-id 200

機能:
    - GitHubから最新のpokefuta.ndjsonを取得
    - PostgreSQL + PostGIS形式のINSERT文を生成
    - ON CONFLICT DO UPDATE で既存データを更新
    - ポケモン名の配列、位置情報（PostGIS POINT）に対応
    - ID範囲を指定して出力可能
"""

import argparse
import json
import sys
import urllib.request
from datetime import datetime

# GitHubの最新NDJSONファイルURL
NDJSON_URL = "https://raw.githubusercontent.com/nishiokya/pokefuta-tracker/main/apps/scraper/pokefuta.ndjson"


def escape_sql_string(s):
    """SQL文字列をエスケープ"""
    if s is None:
        return "NULL"
    # シングルクォートをエスケープ
    return "'" + str(s).replace("'", "''") + "'"


def escape_array(arr):
    """PostgreSQL配列形式にエスケープ"""
    if not arr:
        return "ARRAY[]::TEXT[]"

    # 配列の各要素をエスケープ
    escaped_items = [escape_sql_string(item) for item in arr]
    return "ARRAY[" + ", ".join(escaped_items) + "]"


def generate_sql_from_ndjson(ndjson_url=NDJSON_URL, min_id=None, max_id=None):
    """NDJSONからSQL INSERT文を生成

    Args:
        ndjson_url: NDJSONファイルのURL
        min_id: 最小ID（この値以上のIDを出力）
        max_id: 最大ID（この値以下のIDを出力）
    """

    print(f"-- ポケふたマンホールデータ SQL生成スクリプト", file=sys.stderr)
    print(f"-- 生成日時: {datetime.now().isoformat()}", file=sys.stderr)
    print(f"-- データソース: {ndjson_url}", file=sys.stderr)

    if min_id is not None or max_id is not None:
        filter_msg = "-- フィルタ: "
        if min_id is not None and max_id is not None:
            filter_msg += f"ID {min_id} ~ {max_id}"
        elif min_id is not None:
            filter_msg += f"ID {min_id}以上"
        elif max_id is not None:
            filter_msg += f"ID {max_id}以下"
        print(filter_msg, file=sys.stderr)

    print("", file=sys.stderr)

    # GitHubからNDJSONを取得
    try:
        print(f"データを取得中... {ndjson_url}", file=sys.stderr)
        with urllib.request.urlopen(ndjson_url) as response:
            ndjson_content = response.read().decode('utf-8')
    except Exception as e:
        print(f"エラー: データの取得に失敗しました: {e}", file=sys.stderr)
        sys.exit(1)

    # SQL生成
    print("-- ==========================================")
    print("-- ポケふたマンホールデータ INSERT文")
    print(f"-- 生成日時: {datetime.now().isoformat()}")
    print(f"-- データソース: {ndjson_url}")
    print("-- ==========================================")
    print("")
    print("-- テーブルが存在しない場合は作成")
    print("CREATE TABLE IF NOT EXISTS public.manhole (")
    print("  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,")
    print("  title TEXT,")
    print("  prefecture TEXT,")
    print("  municipality TEXT,")
    print("  location GEOGRAPHY,")
    print("  pokemons TEXT[],")
    print("  detail_url TEXT,")
    print("  source_last_checked TIMESTAMPTZ,")
    print("  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()")
    print(");")
    print("")
    print("-- インデックス作成")
    print("CREATE INDEX IF NOT EXISTS idx_manhole_location_gist ON public.manhole USING GIST(location);")
    print("")

    count = 0
    errors = 0

    for line_num, line in enumerate(ndjson_content.strip().split('\n'), 1):
        if not line.strip():
            continue

        try:
            data = json.loads(line)

            # 必須フィールドのチェック
            if not all(key in data for key in ['id', 'lat', 'lng', 'prefecture']):
                print(f"-- 警告: 行 {line_num} - 必須フィールドが不足しています", file=sys.stderr)
                errors += 1
                continue

            # データ抽出
            manhole_id = int(data['id'])

            # ID範囲フィルタ
            if min_id is not None and manhole_id < min_id:
                continue
            if max_id is not None and manhole_id > max_id:
                continue

            title = data.get('title', '')
            prefecture = data.get('prefecture', '')
            municipality = data.get('city', None)
            lat = float(data['lat'])
            lng = float(data['lng'])
            pokemons = data.get('pokemons', [])
            detail_url = data.get('detail_url', None)
            source_last_checked = data.get('source_last_checked', None)

            # PostGIS POINT形式: POINT(経度 緯度)
            location = f"POINT({lng} {lat})"

            # INSERT文生成（ON CONFLICT DO UPDATE）
            sql = f"""INSERT INTO public.manhole (id, title, prefecture, municipality, location, pokemons, detail_url, source_last_checked)
VALUES (
  {manhole_id},
  {escape_sql_string(title)},
  {escape_sql_string(prefecture)},
  {escape_sql_string(municipality)},
  ST_GeogFromText('SRID=4326;{location}'),
  {escape_array(pokemons)},
  {escape_sql_string(detail_url)},
  {escape_sql_string(source_last_checked)}
)
ON CONFLICT (id) DO UPDATE SET
  title = EXCLUDED.title,
  prefecture = EXCLUDED.prefecture,
  municipality = EXCLUDED.municipality,
  location = EXCLUDED.location,
  pokemons = EXCLUDED.pokemons,
  detail_url = EXCLUDED.detail_url,
  source_last_checked = EXCLUDED.source_last_checked;
"""
            print(sql)
            count += 1

        except json.JSONDecodeError as e:
            print(f"-- エラー: 行 {line_num} - JSON解析失敗: {e}", file=sys.stderr)
            errors += 1
        except Exception as e:
            print(f"-- エラー: 行 {line_num} - {e}", file=sys.stderr)
            errors += 1

    # サマリー
    print("", file=sys.stderr)
    print(f"完了: {count}件のマンホールデータを処理しました", file=sys.stderr)
    if errors > 0:
        print(f"警告: {errors}件のエラーがありました", file=sys.stderr)


def main():
    """メイン関数：コマンドライン引数を解析してSQL生成を実行"""
    parser = argparse.ArgumentParser(
        description='ポケふたNDJSONデータからPostgreSQL INSERTステートメントを生成',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
使用例:
  # 全件出力
  python tools/generate_manhole_sql.py > manhole_data.sql

  # ID 100以下のみ出力
  python tools/generate_manhole_sql.py --max-id 100 > manhole_data.sql

  # ID 50から100まで出力
  python tools/generate_manhole_sql.py --min-id 50 --max-id 100 > manhole_data.sql

  # ID 200以上のみ出力（新規追加分のみ）
  python tools/generate_manhole_sql.py --min-id 200 > new_manholes.sql
        """
    )

    parser.add_argument(
        '--min-id',
        type=int,
        metavar='ID',
        help='最小ID（この値以上のIDを出力）'
    )

    parser.add_argument(
        '--max-id',
        type=int,
        metavar='ID',
        help='最大ID（この値以下のIDを出力）'
    )

    parser.add_argument(
        '--url',
        default=NDJSON_URL,
        metavar='URL',
        help=f'NDJSONファイルのURL（デフォルト: {NDJSON_URL}）'
    )

    args = parser.parse_args()

    # バリデーション
    if args.min_id is not None and args.max_id is not None:
        if args.min_id > args.max_id:
            print("エラー: --min-id は --max-id より小さい値を指定してください", file=sys.stderr)
            sys.exit(1)

    # SQL生成実行
    generate_sql_from_ndjson(
        ndjson_url=args.url,
        min_id=args.min_id,
        max_id=args.max_id
    )


if __name__ == "__main__":
    main()
